#!/usr/bin/perl

use strict;
use warnings;

my @points;

while (<>) {
    chomp;
    my @p = split /,/;
    push @points, { C => \@p, K => key(\@p) };
}

my %conn;
my %cache;
my $iter = 0;

do {

    ++$iter;

    my($min, $end1, $end2);
    for my $p1 (@points) {
        for my $p2 (@points) {
            next if $p1->{K} eq $p2->{K};
            my($sp1, $sp2) = compare($p1, $p2) < 0 ? ($p1, $p2) : ($p2, $p1);
            my $dist = dist($sp1, $sp2);
            if (!defined $min || $dist < $min) {
                if (!exists $conn{$sp1->{K}}{$sp2->{K}}) {
                    $min = $dist;
                    $end1 = $sp1;
                    $end2 = $sp2;
                }
            }
        }
    }
    print "Connecting $end1->{K} to $end2->{K}.\n";
    ++$conn{$end1->{K}}{$end2->{K}};
    ++$conn{$end2->{K}}{$end1->{K}};

    my %circ_seen;
    my @sizes;

    for my $p (sort keys %conn) {
        next if $circ_seen{$p}++;
        my %seen = ($p => 1);
        my @queue = sort keys %{ $conn{$p} };
        while (@queue) {
            my $c = shift @queue;
            $circ_seen{$c}++;
            next if $seen{$c}++;
            push @queue, sort keys %{ $conn{$c} };
        }
        my $size = keys %seen;
        if ($size == @points) {
            print "Last connection found after $iter connections made.\n";
            print "Final two were $end1->{K} and $end2->{K}.\n";
            print "Answer is ", $end1->{C}[0] * $end2->{C}[0], "\n\n";
            exit 0;
        }
    }
} while (1);

sub key {
    my($p) = @_;
    return join(",", @{ $p });
}

sub compare {
    my($p1, $p2) = @_;

    my($c1, $c2) = ($p1->{C}, $p2->{C});

    return $c1->[0] <=> $c2->[0] || $c1->[1] <=> $c2->[1] || $c1->[2] <=> $c2->[2];
}

sub dist {
    my($p1, $p2) = @_;

    ($p1, $p2) = ($p2, $p1) if compare($p1, $p2) > 0;

    my $cache_key = $p1->{K} . " to " . $p2->{K};

    return $cache{$cache_key} if exists $cache{$cache_key};

    my($c1, $c2) = ($p1->{C}, $p2->{C});

    my $dist = sqrt( ($c1->[0] - $c2->[0]) * ($c1->[0] - $c2->[0]) +
                     ($c1->[1] - $c2->[1]) * ($c1->[1] - $c2->[1]) +
                     ($c1->[2] - $c2->[2]) * ($c1->[2] - $c2->[2]) );

    $cache{$cache_key} = $dist;

    return $dist;
}
